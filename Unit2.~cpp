//---------------------------------------------------------------------------
#include <vcl.h>
#include <iostream.h>
#include <conio.h>
#pragma hdrstop

#include "Unit2.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
struct mn {int *M; int numberofel; int predst;} *s; //структура, содержащая множество(массив), переменную кол-ва элементов во множестве и переменную, равную представителю данного множества
int Make_Set(int x ,int nummn, int numelmax){ //Функция создания нового множества(по заданному представителю - первому элементу)
        int setnumber, c;
        setnumber=Find_Set(x, nummn);
        if(setnumber>=0){
                c=2;
                return c;
        }
        else{
                for(int i=0;i<nummn;i++){
                        if(s[i].numberofel==0){
                                s[i].M[0]=x; //запись представителя в множество
                                s[i].predst=x; //и в структуру
                                c=1;
                                s[i].numberofel=1; //кол-во элементов созданного множества равно 1
                                return c;
                        }
                }
        }
}//verno
int Add_Element(int x, int y, int nummn){ //функция добавления переменных к уже созданному множеству с существующим первым элементом - представителем
        int q, c, l;
        q=Find_Set(x, nummn); //поиск множества с заданным представителем
        if(q>=0){ //если представитель найден
                l=Find_Set(y, nummn);
                if(l<0){ //если этот элемент не равен ни одному элементу множеств
                        c=1;
                        s[q].M[s[q].numberofel]=y; //после завершения цикла с проверкой, если не нашло совпадений, запиисываем введённый элемент в множество
                        s[q].numberofel=s[q].numberofel+1; //увеличиваем кол-во элементов множества на введённое кол-во
                        return c;
                }
                else{ //если есть совпадение элементов
                        c=3;
                        return c;
                }
        }
        else{ //если не найден представитель
                c=2;
                return c;
        }
}
int Union(int x, int y, int nummn, int numelmax){ //функция объединения двух множеств по заданным элементам этих множеств
        int c, nomer1, nomer2, nomer3;
        if(nummn<3){
                c=4;
                return c;
        }
        nomer1=Find_Set(x, nummn);
        nomer2=Find_Set(y, nummn);
        if(nomer1<0||nomer2<0){
                c=2;
                return c; //если элемент(ы) не найден(ы), то выводим ошибку;
        }
        else{
                if(nomer1==nomer2) c=3; //если элементы найдены и равны, то выводим информацию об этом
                else{ //если элементы различны
                        for(int i=0;i<nummn;i++){ //ищем в массиве незаполненную структуру
                                if(s[i].numberofel==0){
                                        nomer3=i;
                                        break;
                                }
                                else continue;
                        }
                        c=1;
                        s[nomer3].numberofel=s[nomer1].numberofel+s[nomer2].numberofel; //в эту структуру записываем итоговое кол-во эл-ов
                        delete s[nomer3].M;
                        s[nomer3].M=new int[s[nomer3].numberofel]; //создаём динамический массив элементов, в который и перепишем элементы дву других массивов
                        s[nomer3].predst=s[nomer1].predst; //представителя, равного представителю первого множества
                        for(int i=0;i<s[nomer1].numberofel;i++) s[nomer3].M[i]=s[nomer1].M[i]; //элементы первого множества
                        for(int i=s[nomer1].numberofel, j=0 ; i<s[nomer1].numberofel+s[nomer2].numberofel && j<s[nomer2].numberofel ; i++, j++) s[nomer3].M[i]=s[nomer2].M[j]; //элементы второго множества, начиная после места окончания элементов первого множества
                        delete s[nomer1].M;                      //
                        s[nomer1].M=new int[numelmax];          //
                        s[nomer1].numberofel=0;                //
                        delete s[nomer2].M;                   //"очищаем" ненужные множества для дольнейшего использования
                        s[nomer2].M=new int[numelmax];       //
                        s[nomer2].numberofel=0;             //
                }

        }
        return c;
}
int Find_Set(int x, int nummn){ //функция поиска множества по заданному эл-ту
        int c;
        for(int i=0;i<nummn;i++){
                for(int j=0;j<s[i].numberofel;j++){
                        if(x==s[i].M[j]&&s[i].numberofel>0){
                                c=i;
                                return c;
                        }
                }
        }
        c=-1;
        return c;
}//verno
int All_Sets(int nummn){
        int c;
        for(int i=0;i<nummn;i++){
                if(s[i].numberofel>0){
                        c=1;
                        break;
                }
                else{
                        c=2;
                        return c;
                }
        }
        for(int i=0;i<nummn;i++){
                if(s[i].numberofel>0){
                        cout<<"\npredstavitel="<<s[i].predst<<"\telementy:{";
                        for(int j=0;j<s[i].numberofel;j++){
                                if(j==s[i].numberofel-1){
                                        cout<<s[i].M[j];
                                        break;
                                }
                                cout<<s[i].M[j]<<",";
                        }
                        cout<<"}"<<endl;
                }
        }
        return c;
}//verno
int Certain_Set(int x, int nummn){
        int c;
        for(int i=0;i<nummn;i++){
                if(s[i].numberofel>0&&s[i].predst==x){
                        c=1;
                        cout<<"\npredstavitel="<<s[i].predst<<"\telementy:{";
                        for(int j=0;j<s[i].numberofel;j++){
                                if(j==s[i].numberofel-1){
                                        cout<<s[i].M[j];
                                        break;
                                }
                                cout<<s[i].M[j]<<",";
                        }
                        cout<<"}"<<endl;
                        break;
                }
                else c=2;
        }
        return c;
}//verno
int Find_Set_Predst(int x, int nummn){ //функция поиска множества по заданному эл-ту
        int c;
        for(int i=0;i<nummn;i++){
                for(int j=0;j<s[i].numberofel;j++){
                        if(x==s[i].M[j]&&s[i].numberofel>0){
                                c=s[i].predst;
                                return c;
                        }
                }
        }
}//verno
void Structure(int nummn, int numelmax){
        s=new mn[nummn];
        for(int i=0;i<nummn;i++){
                s[i].M=new int[numelmax];
                s[i].numberofel=0; //инициализация незаполненных множеств
        }
}//verno
